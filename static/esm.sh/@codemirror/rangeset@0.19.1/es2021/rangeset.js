import{MapMode as R}from"../../state@0.19.3/es2021/state.js";var x=class{eq(t){return this==t}range(t,i=t){return new g(t,i,this)}};x.prototype.startSide=x.prototype.endSide=0;x.prototype.point=!1;x.prototype.mapMode=R.TrackDel;var g=class{constructor(t,i,e){this.from=t,this.to=i,this.value=e}};function y(r,t){return r.from-t.from||r.value.startSide-t.value.startSide}var S=class{constructor(t,i,e,n){this.from=t,this.to=i,this.value=e,this.maxPoint=n}get length(){return this.to[this.to.length-1]}findIndex(t,i,e,n=0){let s=e?this.to:this.from;for(let h=n,o=s.length;;){if(h==o)return h;let l=h+o>>1,a=s[l]-t||(e?this.value[l].endSide:this.value[l].startSide)-i;if(l==h)return a>=0?h:o;a>=0?o=l:h=l+1}}between(t,i,e,n){for(let s=this.findIndex(i,-1e9,!0),h=this.findIndex(e,1e9,!1,s);s<h;s++)if(n(this.from[s]+t,this.to[s]+t,this.value[s])===!1)return!1}map(t,i){let e=[],n=[],s=[],h=-1,o=-1;for(let l=0;l<this.value.length;l++){let a=this.value[l],u=this.from[l]+t,c=this.to[l]+t,d,p;if(u==c){let M=i.mapPos(u,a.startSide,a.mapMode);if(M==null)continue;d=p=M}else if(d=i.mapPos(u,a.startSide),p=i.mapPos(c,a.endSide),d>p||d==p&&a.startSide>0&&a.endSide<=0)continue;(p-d||a.endSide-a.startSide)<0||(h<0&&(h=d),a.point&&(o=Math.max(o,p-d)),e.push(a),n.push(d-h),s.push(p-h))}return{mapped:e.length?new S(n,s,e,o):null,pos:h}}},f=class{constructor(t,i,e=f.empty,n){this.chunkPos=t,this.chunk=i,this.nextLayer=e,this.maxPoint=n}get length(){let t=this.chunk.length-1;return t<0?0:Math.max(this.chunkEnd(t),this.nextLayer.length)}get size(){if(this.isEmpty)return 0;let t=this.nextLayer.size;for(let i of this.chunk)t+=i.value.length;return t}chunkEnd(t){return this.chunkPos[t]+this.chunk[t].length}update(t){let{add:i=[],sort:e=!1,filterFrom:n=0,filterTo:s=this.length}=t,h=t.filter;if(i.length==0&&!h)return this;if(e&&i.slice().sort(y),this.isEmpty)return i.length?f.of(i):this;let o=new w(this,null,-1).goto(0),l=0,a=[],u=new v;for(;o.value||l<i.length;)if(l<i.length&&(o.from-i[l].from||o.startSide-i[l].value.startSide)>=0){let c=i[l++];u.addInner(c.from,c.to,c.value)||a.push(c)}else o.rangeIndex==1&&o.chunkIndex<this.chunk.length&&(l==i.length||this.chunkEnd(o.chunkIndex)<i[l].from)&&(!h||n>this.chunkEnd(o.chunkIndex)||s<this.chunkPos[o.chunkIndex])&&u.addChunk(this.chunkPos[o.chunkIndex],this.chunk[o.chunkIndex])?o.nextChunk():((!h||n>o.to||s<o.from||h(o.from,o.to,o.value))&&(u.addInner(o.from,o.to,o.value)||a.push(new g(o.from,o.to,o.value))),o.next());return u.finishInner(this.nextLayer.isEmpty&&!a.length?f.empty:this.nextLayer.update({add:a,filter:h,filterFrom:n,filterTo:s}))}map(t){if(t.length==0||this.isEmpty)return this;let i=[],e=[],n=-1;for(let h=0;h<this.chunk.length;h++){let o=this.chunkPos[h],l=this.chunk[h],a=t.touchesRange(o,o+l.length);if(a===!1)n=Math.max(n,l.maxPoint),i.push(l),e.push(t.mapPos(o));else if(a===!0){let{mapped:u,pos:c}=l.map(o,t);u&&(n=Math.max(n,u.maxPoint),i.push(u),e.push(c))}}let s=this.nextLayer.map(t);return i.length==0?s:new f(e,i,s,n)}between(t,i,e){if(!this.isEmpty){for(let n=0;n<this.chunk.length;n++){let s=this.chunkPos[n],h=this.chunk[n];if(i>=s&&t<=s+h.length&&h.between(s,t-s,i-s,e)===!1)return}this.nextLayer.between(t,i,e)}}iter(t=0){return m.from([this]).goto(t)}get isEmpty(){return this.nextLayer==this}static iter(t,i=0){return m.from(t).goto(i)}static compare(t,i,e,n,s=-1){let h=t.filter(c=>c.maxPoint>=500||!c.isEmpty&&i.indexOf(c)<0&&c.maxPoint>=s),o=i.filter(c=>c.maxPoint>=500||!c.isEmpty&&t.indexOf(c)<0&&c.maxPoint>=s),l=A(h,o),a=new k(h,l,s),u=new k(o,l,s);e.iterGaps((c,d,p)=>L(a,c,u,d,p,n)),e.empty&&e.length==0&&L(a,0,u,0,0,n)}static eq(t,i,e=0,n){n==null&&(n=1e9);let s=t.filter(u=>!u.isEmpty&&i.indexOf(u)<0),h=i.filter(u=>!u.isEmpty&&t.indexOf(u)<0);if(s.length!=h.length)return!1;if(!s.length)return!0;let o=A(s,h),l=new k(s,o,0).goto(e),a=new k(h,o,0).goto(e);for(;;){if(l.to!=a.to||!E(l.active,a.active)||l.point&&(!a.point||!l.point.eq(a.point)))return!1;if(l.to>=n)return!0;l.next(),a.next()}}static spans(t,i,e,n,s=-1){let h=new k(t,null,s).goto(i),o=i,l=h.openStart;for(;;){let a=Math.min(h.to,e);if(h.point?(n.point(o,a,h.point,h.activeForPoint(h.to),l),l=h.openEnd(a)+(h.to>a?1:0)):a>o&&(n.span(o,a,h.active,l),l=h.openEnd(a)),h.to>e)break;o=h.to,h.next()}return l}static of(t,i=!1){let e=new v;for(let n of t instanceof g?[t]:i?C(t):t)e.add(n.from,n.to,n.value);return e.finish()}};f.empty=new f([],[],null,-1);function C(r){if(r.length>1)for(let t=r[0],i=1;i<r.length;i++){let e=r[i];if(y(t,e)>0)return r.slice().sort(y);t=e}return r}f.empty.nextLayer=f.empty;var v=class{constructor(){this.chunks=[],this.chunkPos=[],this.chunkStart=-1,this.last=null,this.lastFrom=-1e9,this.lastTo=-1e9,this.from=[],this.to=[],this.value=[],this.maxPoint=-1,this.setMaxPoint=-1,this.nextLayer=null}finishChunk(t){this.chunks.push(new S(this.from,this.to,this.value,this.maxPoint)),this.chunkPos.push(this.chunkStart),this.chunkStart=-1,this.setMaxPoint=Math.max(this.setMaxPoint,this.maxPoint),this.maxPoint=-1,t&&(this.from=[],this.to=[],this.value=[])}add(t,i,e){this.addInner(t,i,e)||(this.nextLayer||(this.nextLayer=new v)).add(t,i,e)}addInner(t,i,e){let n=t-this.lastTo||e.startSide-this.last.endSide;if(n<=0&&(t-this.lastFrom||e.startSide-this.last.startSide)<0)throw new Error("Ranges must be added sorted by `from` position and `startSide`");return n<0?!1:(this.from.length==250&&this.finishChunk(!0),this.chunkStart<0&&(this.chunkStart=t),this.from.push(t-this.chunkStart),this.to.push(i-this.chunkStart),this.last=e,this.lastFrom=t,this.lastTo=i,this.value.push(e),e.point&&(this.maxPoint=Math.max(this.maxPoint,i-t)),!0)}addChunk(t,i){if((t-this.lastTo||i.value[0].startSide-this.last.endSide)<0)return!1;this.from.length&&this.finishChunk(!0),this.setMaxPoint=Math.max(this.setMaxPoint,i.maxPoint),this.chunks.push(i),this.chunkPos.push(t);let e=i.value.length-1;return this.last=i.value[e],this.lastFrom=i.from[e]+t,this.lastTo=i.to[e]+t,!0}finish(){return this.finishInner(f.empty)}finishInner(t){if(this.from.length&&this.finishChunk(!1),this.chunks.length==0)return t;let i=new f(this.chunkPos,this.chunks,this.nextLayer?this.nextLayer.finishInner(t):t,this.setMaxPoint);return this.from=null,i}};function A(r,t){let i=new Map;for(let n of r)for(let s=0;s<n.chunk.length;s++)n.chunk[s].maxPoint<500&&i.set(n.chunk[s],n.chunkPos[s]);let e=new Set;for(let n of t)for(let s=0;s<n.chunk.length;s++)i.get(n.chunk[s])==n.chunkPos[s]&&e.add(n.chunk[s]);return e}var w=class{constructor(t,i,e,n=0){this.layer=t,this.skip=i,this.minPoint=e,this.rank=n}get startSide(){return this.value?this.value.startSide:0}get endSide(){return this.value?this.value.endSide:0}goto(t,i=-1e9){return this.chunkIndex=this.rangeIndex=0,this.gotoInner(t,i,!1),this}gotoInner(t,i,e){for(;this.chunkIndex<this.layer.chunk.length;){let n=this.layer.chunk[this.chunkIndex];if(!(this.skip&&this.skip.has(n)||this.layer.chunkEnd(this.chunkIndex)<t||n.maxPoint<this.minPoint))break;this.chunkIndex++,e=!1}if(this.chunkIndex<this.layer.chunk.length){let n=this.layer.chunk[this.chunkIndex].findIndex(t-this.layer.chunkPos[this.chunkIndex],i,!0);(!e||this.rangeIndex<n)&&this.setRangeIndex(n)}this.next()}forward(t,i){(this.to-t||this.endSide-i)<0&&this.gotoInner(t,i,!0)}next(){for(;;)if(this.chunkIndex==this.layer.chunk.length){this.from=this.to=1e9,this.value=null;break}else{let t=this.layer.chunkPos[this.chunkIndex],i=this.layer.chunk[this.chunkIndex],e=t+i.from[this.rangeIndex];if(this.from=e,this.to=t+i.to[this.rangeIndex],this.value=i.value[this.rangeIndex],this.setRangeIndex(this.rangeIndex+1),this.minPoint<0||this.value.point&&this.to-this.from>=this.minPoint)break}}setRangeIndex(t){if(t==this.layer.chunk[this.chunkIndex].value.length){if(this.chunkIndex++,this.skip)for(;this.chunkIndex<this.layer.chunk.length&&this.skip.has(this.layer.chunk[this.chunkIndex]);)this.chunkIndex++;this.rangeIndex=0}else this.rangeIndex=t}nextChunk(){this.chunkIndex++,this.rangeIndex=0,this.next()}compare(t){return this.from-t.from||this.startSide-t.startSide||this.to-t.to||this.endSide-t.endSide}},m=class{constructor(t){this.heap=t}static from(t,i=null,e=-1){let n=[];for(let s=0;s<t.length;s++)for(let h=t[s];!h.isEmpty;h=h.nextLayer)h.maxPoint>=e&&n.push(new w(h,i,e,s));return n.length==1?n[0]:new m(n)}get startSide(){return this.value?this.value.startSide:0}goto(t,i=-1e9){for(let e of this.heap)e.goto(t,i);for(let e=this.heap.length>>1;e>=0;e--)T(this.heap,e);return this.next(),this}forward(t,i){for(let e of this.heap)e.forward(t,i);for(let e=this.heap.length>>1;e>=0;e--)T(this.heap,e);(this.to-t||this.value.endSide-i)<0&&this.next()}next(){if(this.heap.length==0)this.from=this.to=1e9,this.value=null,this.rank=-1;else{let t=this.heap[0];this.from=t.from,this.to=t.to,this.value=t.value,this.rank=t.rank,t.value&&t.next(),T(this.heap,0)}}};function T(r,t){for(let i=r[t];;){let e=(t<<1)+1;if(e>=r.length)break;let n=r[e];if(e+1<r.length&&n.compare(r[e+1])>=0&&(n=r[e+1],e++),i.compare(n)<0)break;r[e]=i,r[t]=n,t=e}}var k=class{constructor(t,i,e){this.minPoint=e,this.active=[],this.activeTo=[],this.activeRank=[],this.minActive=-1,this.point=null,this.pointFrom=0,this.pointRank=0,this.to=-1e9,this.endSide=0,this.openStart=-1,this.cursor=m.from(t,i,e)}goto(t,i=-1e9){return this.cursor.goto(t,i),this.active.length=this.activeTo.length=this.activeRank.length=0,this.minActive=-1,this.to=t,this.endSide=i,this.openStart=-1,this.next(),this}forward(t,i){for(;this.minActive>-1&&(this.activeTo[this.minActive]-t||this.active[this.minActive].endSide-i)<0;)this.removeActive(this.minActive);this.cursor.forward(t,i)}removeActive(t){P(this.active,t),P(this.activeTo,t),P(this.activeRank,t),this.minActive=F(this.active,this.activeTo)}addActive(t){let i=0,{value:e,to:n,rank:s}=this.cursor;for(;i<this.activeRank.length&&this.activeRank[i]<=s;)i++;I(this.active,i,e),I(this.activeTo,i,n),I(this.activeRank,i,s),t&&I(t,i,this.cursor.from),this.minActive=F(this.active,this.activeTo)}next(){let t=this.to,i=this.point;this.point=null;let e=this.openStart<0?[]:null,n=0;for(;;){let s=this.minActive;if(s>-1&&(this.activeTo[s]-this.cursor.from||this.active[s].endSide-this.cursor.startSide)<0){if(this.activeTo[s]>t){this.to=this.activeTo[s],this.endSide=this.active[s].endSide;break}this.removeActive(s),e&&P(e,s)}else if(this.cursor.value)if(this.cursor.from>t){this.to=this.cursor.from,this.endSide=this.cursor.startSide;break}else{let h=this.cursor.value;if(!h.point)this.addActive(e),this.cursor.next();else if(i&&this.cursor.to==this.to&&this.cursor.from<this.cursor.to&&h.endSide==this.endSide)this.cursor.next();else{this.point=h,this.pointFrom=this.cursor.from,this.pointRank=this.cursor.rank,this.to=this.cursor.to,this.endSide=h.endSide,this.cursor.from<t&&(n=1),this.cursor.next(),this.to>t&&this.forward(this.to,this.endSide);break}}else{this.to=this.endSide=1e9;break}}if(e){let s=0;for(;s<e.length&&e[s]<t;)s++;this.openStart=s+n}}activeForPoint(t){if(!this.active.length)return this.active;let i=[];for(let e=this.active.length-1;e>=0&&!(this.activeRank[e]<this.pointRank);e--)(this.activeTo[e]>t||this.activeTo[e]==t&&this.active[e].endSide>=this.point.endSide)&&i.push(this.active[e]);return i.reverse()}openEnd(t){let i=0;for(let e=this.activeTo.length-1;e>=0&&this.activeTo[e]>t;e--)i++;return i}};function L(r,t,i,e,n,s){r.goto(t),i.goto(e);let h=e+n,o=e,l=e-t;for(;;){let a=r.to+l-i.to||r.endSide-i.endSide,u=a<0?r.to+l:i.to,c=Math.min(u,h);if(r.point||i.point?r.point&&i.point&&(r.point==i.point||r.point.eq(i.point))&&E(r.activeForPoint(r.to+l),i.activeForPoint(i.to))||s.comparePoint(o,c,r.point,i.point):c>o&&!E(r.active,i.active)&&s.compareRange(o,c,r.active,i.active),u>h)break;o=u,a<=0&&r.next(),a>=0&&i.next()}}function E(r,t){if(r.length!=t.length)return!1;for(let i=0;i<r.length;i++)if(r[i]!=t[i]&&!r[i].eq(t[i]))return!1;return!0}function P(r,t){for(let i=t,e=r.length-1;i<e;i++)r[i]=r[i+1];r.pop()}function I(r,t,i){for(let e=r.length-1;e>=t;e--)r[e+1]=r[e];r[t]=i}function F(r,t){let i=-1,e=1e9;for(let n=0;n<t.length;n++)(t[n]-e||r[n].endSide-r[i].endSide)<0&&(i=n,e=t[n]);return i}export{g as Range,f as RangeSet,v as RangeSetBuilder,x as RangeValue};
