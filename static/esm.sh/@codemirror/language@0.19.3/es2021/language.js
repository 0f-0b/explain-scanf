import{NodeProp as g,Tree as p,TreeFragment as x,Parser as W,NodeType as z}from"../../../@lezer/common@0.15.7/es2021/common.js";import{Facet as w,EditorState as k,StateEffect as M,StateField as U}from"../../state@0.19.3/es2021/state.js";import{ViewPlugin as V}from"../../view@0.19.12/es2021/view.js";import{countColumn as $}from"../../text@0.19.5/es2021/text.js";var S=new g;function q(n){return w.define({combine:n?t=>t.concat(n):void 0})}var u=class{constructor(t,e,r,i=[]){this.data=t,this.topNode=r,k.prototype.hasOwnProperty("tree")||Object.defineProperty(k.prototype,"tree",{get(){return v(this)}}),this.parser=e,this.extension=[m.of(this),k.languageData.of((s,o,a)=>s.facet(b(s,o,a)))].concat(i)}isActiveAt(t,e,r=-1){return b(t,e,r)==this.data}findRegions(t){let e=t.facet(m);if((e==null?void 0:e.data)==this.data)return[{from:0,to:t.doc.length}];if(!e||!e.allowsNesting)return[];let r=[],i=(s,o)=>{if(s.prop(S)==this.data){r.push({from:o,to:o+s.length});return}let a=s.prop(g.mounted);if(a){if(a.tree.prop(S)==this.data){if(a.overlay)for(let l of a.overlay)r.push({from:l.from+o,to:l.to+o});else r.push({from:o,to:o+s.length});return}else if(a.overlay){let l=r.length;if(i(a.tree,a.overlay[0].from+o),r.length>l)return}}for(let l=0;l<s.children.length;l++){let h=s.children[l];h instanceof p&&i(h,s.positions[l]+o)}};return i(v(t),0),r}get allowsNesting(){return!0}};u.setState=M.define();function b(n,t,e){let r=n.facet(m);if(!r)return null;let i=r.data;if(r.allowsNesting)for(let s=v(n).topNode;s;s=s.enter(t,e,!0,!1))i=s.type.prop(S)||i;return i}var P=class extends u{constructor(t,e){super(t,e,e.topNode);this.parser=e}static define(t){let e=q(t.languageData);return new P(e,t.parser.configure({props:[S.add(r=>r.isTop?e:void 0)]}))}configure(t){return new P(this.data,this.parser.configure(t))}get allowsNesting(){return this.parser.wrappers.length>0}};function v(n){let t=n.field(u.state,!1);return t?t.tree:p.empty}function dt(n,t,e=50){var r;let i=(r=n.field(u.state,!1))===null||r===void 0?void 0:r.context;return i&&(i.treeLen>=t||i.work(e,t))?i.tree:null}var O=class{constructor(t,e=t.length){this.doc=t,this.length=e,this.cursorPos=0,this.string="",this.cursor=t.iter()}syncTo(t){return this.string=this.cursor.next(t-this.cursorPos).value,this.cursorPos=t+this.string.length,this.cursorPos-this.string.length}chunk(t){return this.syncTo(t),this.string}get lineChunks(){return!0}read(t,e){let r=this.cursorPos-this.string.length;return t<r||e>=this.cursorPos?this.doc.sliceString(t,e):this.string.slice(t-r,e-r)}},y=null,C=class{constructor(t,e,r=[],i,s,o,a,l){this.parser=t,this.state=e,this.fragments=r,this.tree=i,this.treeLen=s,this.viewport=o,this.skipped=a,this.scheduleOn=l,this.parse=null,this.tempSkipped=[]}startParse(){return this.parser.startParse(new O(this.state.doc),this.fragments)}work(t,e){return e!=null&&e>=this.state.doc.length&&(e=void 0),this.tree!=p.empty&&this.isDone(e??this.state.doc.length)?(this.takeTree(),!0):this.withContext(()=>{var r;this.parse||(this.parse=this.startParse()),e!=null&&(this.parse.stoppedAt==null||this.parse.stoppedAt>e)&&e<this.state.doc.length&&this.parse.stopAt(e);let i=Date.now()+t;for(;;){let s=this.parse.advance();if(s)if(this.fragments=this.withoutTempSkipped(x.addTree(s,this.fragments,this.parse.stoppedAt!=null)),this.treeLen=(r=this.parse.stoppedAt)!==null&&r!==void 0?r:this.state.doc.length,this.tree=s,this.parse=null,this.treeLen<(e??this.state.doc.length))this.parse=this.startParse();else return!0;if(Date.now()>i)return!1}})}takeTree(){let t,e;this.parse&&(t=this.parse.parsedPos)>this.treeLen&&((this.parse.stoppedAt==null||this.parse.stoppedAt>t)&&this.parse.stopAt(t),this.withContext(()=>{for(;!(e=this.parse.advance()););}),this.tree=e,this.fragments=this.withoutTempSkipped(x.addTree(this.tree,this.fragments,!0)),this.parse=null)}withContext(t){let e=y;y=this;try{return t()}finally{y=e}}withoutTempSkipped(t){for(let e;e=this.tempSkipped.pop();)t=D(t,e.from,e.to);return t}changes(t,e){let{fragments:r,tree:i,treeLen:s,viewport:o,skipped:a}=this;if(this.takeTree(),!t.empty){let l=[];if(t.iterChangedRanges((h,f,d,A)=>l.push({fromA:h,toA:f,fromB:d,toB:A})),r=x.applyChanges(r,l),i=p.empty,s=0,o={from:t.mapPos(o.from,-1),to:t.mapPos(o.to,1)},this.skipped.length){a=[];for(let h of this.skipped){let f=t.mapPos(h.from,1),d=t.mapPos(h.to,-1);f<d&&a.push({from:f,to:d})}}}return new C(this.parser,e,r,i,s,o,a,this.scheduleOn)}updateViewport(t){if(this.viewport.from==t.from&&this.viewport.to==t.to)return!1;this.viewport=t;let e=this.skipped.length;for(let r=0;r<this.skipped.length;r++){let{from:i,to:s}=this.skipped[r];i<t.to&&s>t.from&&(this.fragments=D(this.fragments,i,s),this.skipped.splice(r--,1))}return this.skipped.length>=e?!1:(this.reset(),!0)}reset(){this.parse&&(this.takeTree(),this.parse=null)}skipUntilInView(t,e){this.skipped.push({from:t,to:e})}static getSkippingParser(t){return new class extends W{createParse(e,r,i){let s=i[0].from,o=i[i.length-1].to;return{parsedPos:s,advance(){let l=y;if(l){for(let h of i)l.tempSkipped.push(h);t&&(l.scheduleOn=l.scheduleOn?Promise.all([l.scheduleOn,t]):t)}return this.parsedPos=o,new p(z.none,[],[],o-s)},stoppedAt:null,stopAt(){}}}}}movedPast(t){return this.treeLen<t&&this.parse&&this.parse.parsedPos>=t}isDone(t){let e=this.fragments;return this.treeLen>=t&&e.length&&e[0].from==0&&e[0].to>=t}static get(){return y}};function D(n,t,e){return x.applyChanges(n,[{fromA:t,toA:e,fromB:t,toB:e}])}var c=class{constructor(t){this.context=t,this.tree=t.tree}apply(t){if(!t.docChanged)return this;let e=this.context.changes(t.changes,t.state),r=this.context.treeLen==t.startState.doc.length?void 0:Math.max(t.changes.mapPos(this.context.treeLen),e.viewport.to);return e.work(25,r)||e.takeTree(),new c(e)}static init(t){let e=new C(t.facet(m).parser,t,[],p.empty,0,{from:0,to:t.doc.length},[],null);return e.work(25)||e.takeTree(),new c(e)}};u.state=U.define({create:c.init,update(n,t){for(let e of t.effects)if(e.is(u.setState))return e.value;return t.startState.facet(m)!=t.state.facet(m)?c.init(t.state):n.apply(t)}});var j=typeof window!="undefined"&&window.requestIdleCallback||((n,{timeout:t})=>setTimeout(n,t)),H=typeof window!="undefined"&&window.cancelIdleCallback||clearTimeout,J=V.fromClass(class{constructor(t){this.view=t,this.working=-1,this.chunkEnd=-1,this.chunkBudget=-1,this.work=this.work.bind(this),this.scheduleWork()}update(t){let e=this.view.state.field(u.state).context;(e.updateViewport(t.view.viewport)||this.view.viewport.to>e.treeLen)&&this.scheduleWork(),t.docChanged&&(this.view.hasFocus&&(this.chunkBudget+=50),this.scheduleWork()),this.checkAsyncSchedule(e)}scheduleWork(){if(this.working>-1)return;let{state:t}=this.view,e=t.field(u.state);(e.tree!=e.context.tree||!e.context.isDone(t.doc.length))&&(this.working=j(this.work,{timeout:500}))}work(t){this.working=-1;let e=Date.now();if(this.chunkEnd<e&&(this.chunkEnd<0||this.view.hasFocus)&&(this.chunkEnd=e+3e4,this.chunkBudget=3e3),this.chunkBudget<=0)return;let{state:r,viewport:{to:i}}=this.view,s=r.field(u.state);if(s.tree==s.context.tree&&s.context.treeLen>=i+1e6)return;let o=Math.min(this.chunkBudget,t?Math.max(25,t.timeRemaining()):100),a=s.context.work(o,i+1e6);this.chunkBudget-=Date.now()-e,(a||this.chunkBudget<=0||s.context.movedPast(i))&&(s.context.takeTree(),this.view.dispatch({effects:u.setState.of(new c(s.context))})),!a&&this.chunkBudget>0&&this.scheduleWork(),this.checkAsyncSchedule(s.context)}checkAsyncSchedule(t){t.scheduleOn&&(t.scheduleOn.then(()=>this.scheduleWork()),t.scheduleOn=null)}destroy(){this.working>=0&&H(this.working)}},{eventHandlers:{focus(){this.scheduleWork()}}}),m=w.define({combine(n){return n.length?n[0]:null},enables:[u.state,J]}),R=class{constructor(t,e=[]){this.language=t,this.support=e,this.extension=[t,e]}},I=class{constructor(t,e,r,i,s){this.name=t,this.alias=e,this.extensions=r,this.filename=i,this.loadFunc=s,this.support=void 0,this.loading=null}load(){return this.loading||(this.loading=this.loadFunc().then(t=>this.support=t,t=>{throw this.loading=null,t}))}static of(t){return new I(t.name,(t.alias||[]).concat(t.name).map(e=>e.toLowerCase()),t.extensions||[],t.filename,t.load)}static matchFilename(t,e){for(let i of t)if(i.filename&&i.filename.test(e))return i;let r=/\.([^.]+)$/.exec(e);if(r){for(let i of t)if(i.extensions.indexOf(r[1])>-1)return i}return null}static matchLanguageName(t,e,r=!0){e=e.toLowerCase();for(let i of t)if(i.alias.some(s=>s==e))return i;if(r)for(let i of t)for(let s of i.alias){let o=e.indexOf(s);if(o>-1&&(s.length>2||!/\w/.test(e[o-1])&&!/\w/.test(e[o+s.length])))return i}return null}},G=w.define(),F=w.define({combine:n=>{if(!n.length)return"  ";if(!/^(?: +|\t+)$/.test(n[0]))throw new Error("Invalid indent unit: "+JSON.stringify(n[0]));return n[0]}});function K(n){let t=n.facet(F);return t.charCodeAt(0)==9?n.tabSize*t.length:t.length}function Q(n,t){let e="",r=n.tabSize;if(n.facet(F).charCodeAt(0)==9)for(;t>=r;)e+="	",t-=r;for(let i=0;i<t;i++)e+=" ";return e}function X(n,t){n instanceof k&&(n=new T(n));for(let r of n.state.facet(G)){let i=r(n,t);if(i!=null)return i}let e=v(n.state);return e?Z(n,e,t):null}var T=class{constructor(t,e={}){this.state=t,this.options=e,this.unit=K(t)}lineAt(t,e=1){let r=this.state.doc.lineAt(t),{simulateBreak:i}=this.options;return i!=null&&i>=r.from&&i<=r.to?(e<0?i<t:i<=t)?{text:r.text.slice(i-r.from),from:i}:{text:r.text.slice(0,i-r.from),from:r.from}:r}textAfterPos(t,e=1){if(this.options.simulateDoubleBreak&&t==this.options.simulateBreak)return"";let{text:r,from:i}=this.lineAt(t,e);return r.slice(t-i,Math.min(r.length,t+100-i))}column(t,e=1){let{text:r,from:i}=this.lineAt(t,e),s=this.countColumn(r,t-i),o=this.options.overrideIndentation?this.options.overrideIndentation(i):-1;return o>-1&&(s+=o-this.countColumn(r,r.search(/\S|$/))),s}countColumn(t,e=t.length){return $(t,this.state.tabSize,e)}lineIndent(t,e=1){let{text:r,from:i}=this.lineAt(t,e),s=this.options.overrideIndentation;if(s){let o=s(i);if(o>-1)return o}return this.countColumn(r,r.search(/\S|$/))}get simulatedBreak(){return this.options.simulateBreak||null}},Y=new g;function Z(n,t,e){return N(t.resolveInner(e).enterUnfinishedNodesBefore(e),e,n)}function _(n){return n.pos==n.options.simulateBreak&&n.options.simulateDoubleBreak}function tt(n){let t=n.type.prop(Y);if(t)return t;let e=n.firstChild,r;if(e&&(r=e.type.prop(g.closedBy))){let i=n.lastChild,s=i&&r.indexOf(i.name)>-1;return o=>E(o,!0,1,void 0,s&&!_(o)?i.from:void 0)}return n.parent==null?et:null}function N(n,t,e){for(;n;n=n.parent){let r=tt(n);if(r)return r(new L(e,t,n))}return null}function et(){return 0}var L=class extends T{constructor(t,e,r){super(t.state,t.options);this.base=t,this.pos=e,this.node=r}get textAfter(){return this.textAfterPos(this.pos)}get baseIndent(){let t=this.state.doc.lineAt(this.node.from);for(;;){let e=this.node.resolve(t.from);for(;e.parent&&e.parent.from==e.from;)e=e.parent;if(nt(e,this.node))break;t=this.state.doc.lineAt(e.from)}return this.lineIndent(t.from)}continue(){let t=this.node.parent;return t?N(t,this.pos,this.base):0}};function nt(n,t){for(let e=t;e;e=e.parent)if(n==e)return!0;return!1}function rt(n){let t=n.node,e=t.childAfter(t.from),r=t.lastChild;if(!e)return null;let i=n.options.simulateBreak,s=n.state.doc.lineAt(e.from),o=i==null||i<=s.from?s.to:Math.min(s.to,i);for(let a=e.to;;){let l=t.childAfter(a);if(!l||l==r)return null;if(!l.type.isSkipped)return l.from<o?e:null;a=l.to}}function pt({closing:n,align:t=!0,units:e=1}){return r=>E(r,t,e,n)}function E(n,t,e,r,i){let s=n.textAfter,o=s.match(/^\s*/)[0].length,a=r&&s.slice(o,o+r.length)==r||i==n.pos+o,l=t?rt(n):null;return l?a?n.column(l.from):n.column(l.to):n.baseIndent+(a?0:n.unit*e)}var mt=n=>n.baseIndent;function gt({except:n,units:t=1}={}){return e=>{let r=n&&n.test(e.textAfter);return e.baseIndent+(r?0:t*e.unit)}}var it=200;function wt(){return k.transactionFilter.of(n=>{if(!n.docChanged||!n.isUserEvent("input.type"))return n;let t=n.startState.languageDataAt("indentOnInput",n.startState.selection.main.head);if(!t.length)return n;let e=n.newDoc,{head:r}=n.newSelection.main,i=e.lineAt(r);if(r>i.from+it)return n;let s=e.sliceString(i.from,r);if(!t.some(h=>h.test(s)))return n;let{state:o}=n,a=-1,l=[];for(let{head:h}of o.selection.ranges){let f=o.doc.lineAt(h);if(f.from==a)continue;a=f.from;let d=X(o,f.from);if(d==null)continue;let A=/^\s*/.exec(f.text)[0],B=Q(o,d);A!=B&&l.push({from:f.from,to:f.from+A.length,insert:B})}return l.length?[n,{changes:l,sequential:!0}]:n})}var st=w.define(),ot=new g;function kt(n){let t=n.firstChild,e=n.lastChild;return t&&t.to<e.from?{from:t.to,to:e.type.isError?n.to:e.from}:null}function lt(n,t,e){let r=v(n);if(r.length==0)return null;let i=r.resolveInner(e),s=null;for(let o=i;o;o=o.parent){if(o.to<=e||o.from>e)continue;if(s&&o.from<t)break;let a=o.type.prop(ot);if(a){let l=a(o,n);l&&l.from<=e&&l.from>=t&&l.to>e&&(s=l)}}return s}function vt(n,t,e){for(let r of n.facet(st)){let i=r(n,t,e);if(i)return i}return lt(n,t,e)}export{T as IndentContext,P as LRLanguage,u as Language,I as LanguageDescription,R as LanguageSupport,C as ParseContext,L as TreeIndentContext,gt as continuedIndent,q as defineLanguageFacet,pt as delimitedIndent,dt as ensureSyntaxTree,mt as flatIndent,kt as foldInside,ot as foldNodeProp,st as foldService,vt as foldable,K as getIndentUnit,X as getIndentation,Y as indentNodeProp,wt as indentOnInput,G as indentService,Q as indentString,F as indentUnit,m as language,S as languageDataProp,v as syntaxTree};
