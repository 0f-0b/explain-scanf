var be=1024,xe=0,_=class{constructor(e,t){this.from=e,this.to=t}},v=class{constructor(e={}){this.id=xe++,this.perNode=!!e.perNode,this.deserialize=e.deserialize||(()=>{throw new Error("This node type doesn't define a deserialize function")})}add(e){if(this.perNode)throw new RangeError("Can't add per-node props to node types");return typeof e!="function"&&(e=F.match(e)),t=>{let r=e(t);return r===void 0?null:[this,r]}}};v.closedBy=new v({deserialize:h=>h.split(" ")});v.openedBy=new v({deserialize:h=>h.split(" ")});v.group=new v({deserialize:h=>h.split(" ")});v.contextHash=new v({perNode:!0});v.lookAhead=new v({perNode:!0});v.mounted=new v({perNode:!0});var ne=class{constructor(e,t,r){this.tree=e,this.overlay=t,this.parser=r}},ye=Object.create(null),F=class{constructor(e,t,r,i=0){this.name=e,this.props=t,this.id=r,this.flags=i}static define(e){let t=e.props&&e.props.length?Object.create(null):ye,r=(e.top?1:0)|(e.skipped?2:0)|(e.error?4:0)|(e.name==null?8:0),i=new F(e.name||"",t,e.id,r);if(e.props){for(let n of e.props)if(Array.isArray(n)||(n=n(i)),n){if(n[0].perNode)throw new RangeError("Can't store a per-node prop on a node type");t[n[0].id]=n[1]}}return i}prop(e){return this.props[e.id]}get isTop(){return(this.flags&1)>0}get isSkipped(){return(this.flags&2)>0}get isError(){return(this.flags&4)>0}get isAnonymous(){return(this.flags&8)>0}is(e){if(typeof e=="string"){if(this.name==e)return!0;let t=this.prop(v.group);return t?t.indexOf(e)>-1:!1}return this.id==e}static match(e){let t=Object.create(null);for(let r in e)for(let i of r.split(" "))t[i]=e[r];return r=>{for(let i=r.prop(v.group),n=-1;n<(i?i.length:0);n++){let s=t[n<0?r.name:i[n]];if(s)return s}}}};F.none=new F("",Object.create(null),0,8);var X=class{constructor(e){this.types=e;for(let t=0;t<e.length;t++)if(e[t].id!=t)throw new RangeError("Node type ids should correspond to array positions when creating a node set")}extend(...e){let t=[];for(let r of this.types){let i=null;for(let n of e){let s=n(r);s&&(i||(i=Object.assign({},r.props)),i[s[0].id]=s[1])}t.push(i?new F(r.name,i,r.id,r.flags):r)}return new X(t)}},se=new WeakMap,z=class{constructor(e,t,r,i,n){if(this.type=e,this.children=t,this.positions=r,this.length=i,this.props=null,n&&n.length){this.props=Object.create(null);for(let[s,l]of n)this.props[typeof s=="number"?s:s.id]=l}}toString(){let e=this.prop(v.mounted);if(e&&!e.overlay)return e.tree.toString();let t="";for(let r of this.children){let i=r.toString();i&&(t&&(t+=","),t+=i)}return this.type.name?(/\W/.test(this.type.name)&&!this.type.isError?JSON.stringify(this.type.name):this.type.name)+(t.length?"("+t+")":""):t}cursor(e,t=0){let r=e!=null&&se.get(this)||this.topNode,i=new V(r);return e!=null&&(i.moveTo(e,t),se.set(this,i._tree)),i}fullCursor(){return new V(this.topNode,1)}get topNode(){return new E(this,0,0,null)}resolve(e,t=0){return this.cursor(e,t).node}resolveInner(e,t=0){let r=this.topNode;for(;;){let i=r.enter(e,t);if(!i)return r;r=i}}iterate(e){let{enter:t,leave:r,from:i=0,to:n=this.length}=e;for(let s=this.cursor(),l=()=>s.node;;){let o=!1;if(s.from<=n&&s.to>=i&&(s.type.isAnonymous||t(s.type,s.from,s.to,l)!==!1)){if(s.firstChild())continue;s.type.isAnonymous||(o=!0)}for(;o&&r&&r(s.type,s.from,s.to,l),o=s.type.isAnonymous,!s.nextSibling();){if(!s.parent())return;o=!0}}}prop(e){return e.perNode?this.props?this.props[e.id]:void 0:this.type.prop(e)}get propValues(){let e=[];if(this.props)for(let t in this.props)e.push([+t,this.props[t]]);return e}balance(e={}){return this.children.length<=8?this:Z(this.type,this.children,this.positions,0,this.children.length,0,this.length,(t,r,i)=>new z(this.type,t,r,i,this.propValues),e.makeTree||((t,r,i)=>new z(F.none,t,r,i)))}static build(e){return we(e)}};z.empty=new z(F.none,[],[],0);var q=class{constructor(e,t){this.buffer=e,this.index=t}get id(){return this.buffer[this.index-4]}get start(){return this.buffer[this.index-3]}get end(){return this.buffer[this.index-2]}get size(){return this.buffer[this.index-1]}get pos(){return this.index}next(){this.index-=4}fork(){return new q(this.buffer,this.index)}},R=class{constructor(e,t,r){this.buffer=e,this.length=t,this.set=r}get type(){return F.none}toString(){let e=[];for(let t=0;t<this.buffer.length;)e.push(this.childString(t)),t=this.buffer[t+3];return e.join(",")}childString(e){let t=this.buffer[e],r=this.buffer[e+3],i=this.set.types[t],n=i.name;if(/\W/.test(n)&&!i.isError&&(n=JSON.stringify(n)),e+=4,r==e)return n;let s=[];for(;e<r;)s.push(this.childString(e)),e=this.buffer[e+3];return n+"("+s.join(",")+")"}findChild(e,t,r,i,n){let{buffer:s}=this,l=-1;for(let o=e;o!=t&&!(le(n,i,s[o+1],s[o+2])&&(l=o,r>0));o=s[o+3]);return l}slice(e,t,r,i){let n=this.buffer,s=new Uint16Array(t-e);for(let l=e,o=0;l<t;)s[o++]=n[l++],s[o++]=n[l++]-r,s[o++]=n[l++]-r,s[o++]=n[l++]-e;return new R(s,i-r,this.set)}};function le(h,e,t,r){switch(h){case-2:return t<e;case-1:return r>=e&&t<e;case 0:return t<e&&r>e;case 1:return t<=e&&r>e;case 2:return r>e;case 4:return!0}}function he(h,e){let t=h.childBefore(e);for(;t;){let r=t.lastChild;if(!r||r.to!=t.to)break;r.type.isError&&r.from==r.to?(h=t,t=r.prevSibling):t=r}return h}var E=class{constructor(e,t,r,i){this.node=e,this._from=t,this.index=r,this._parent=i}get type(){return this.node.type}get name(){return this.node.type.name}get from(){return this._from}get to(){return this._from+this.node.length}nextChild(e,t,r,i,n=0){for(let s=this;;){for(let{children:l,positions:o}=s.node,u=t>0?l.length:-1;e!=u;e+=t){let f=l[e],d=o[e]+s._from;if(!!le(i,r,d,d+f.length)){if(f instanceof R){if(n&2)continue;let p=f.findChild(0,f.buffer.length,t,r-d,i);if(p>-1)return new I(new oe(s,f,e,d),null,p)}else if(n&1||!f.type.isAnonymous||Y(f)){let p;if(f.props&&(p=f.prop(v.mounted))&&!p.overlay)return new E(p.tree,d,e,s);let c=new E(f,d,e,s);return n&1||!c.type.isAnonymous?c:c.nextChild(t<0?f.children.length-1:0,t,r,i)}}}if(n&1||!s.type.isAnonymous||(s.index>=0?e=s.index+t:e=t<0?-1:s._parent.node.children.length,s=s._parent,!s))return null}}get firstChild(){return this.nextChild(0,1,0,4)}get lastChild(){return this.nextChild(this.node.children.length-1,-1,0,4)}childAfter(e){return this.nextChild(0,1,e,2)}childBefore(e){return this.nextChild(this.node.children.length-1,-1,e,-2)}enter(e,t,r=!0,i=!0){let n;if(r&&(n=this.node.prop(v.mounted))&&n.overlay){let s=e-this.from;for(let{from:l,to:o}of n.overlay)if((t>0?l<=s:l<s)&&(t<0?o>=s:o>s))return new E(n.tree,n.overlay[0].from+this.from,-1,this)}return this.nextChild(0,1,e,t,i?0:2)}nextSignificantParent(){let e=this;for(;e.type.isAnonymous&&e._parent;)e=e._parent;return e}get parent(){return this._parent?this._parent.nextSignificantParent():null}get nextSibling(){return this._parent&&this.index>=0?this._parent.nextChild(this.index+1,1,0,4):null}get prevSibling(){return this._parent&&this.index>=0?this._parent.nextChild(this.index-1,-1,0,4):null}get cursor(){return new V(this)}get tree(){return this.node}toTree(){return this.node}resolve(e,t=0){return this.cursor.moveTo(e,t).node}enterUnfinishedNodesBefore(e){return he(this,e)}getChild(e,t=null,r=null){let i=K(this,e,t,r);return i.length?i[0]:null}getChildren(e,t=null,r=null){return K(this,e,t,r)}toString(){return this.node.toString()}};function K(h,e,t,r){let i=h.cursor,n=[];if(!i.firstChild())return n;if(t!=null){for(;!i.type.is(t);)if(!i.nextSibling())return n}for(;;){if(r!=null&&i.type.is(r))return n;if(i.type.is(e)&&n.push(i.node),!i.nextSibling())return r==null?n:[]}}var oe=class{constructor(e,t,r,i){this.parent=e,this.buffer=t,this.index=r,this.start=i}},I=class{constructor(e,t,r){this.context=e,this._parent=t,this.index=r,this.type=e.buffer.set.types[e.buffer.buffer[r]]}get name(){return this.type.name}get from(){return this.context.start+this.context.buffer.buffer[this.index+1]}get to(){return this.context.start+this.context.buffer.buffer[this.index+2]}child(e,t,r){let{buffer:i}=this.context,n=i.findChild(this.index+4,i.buffer[this.index+3],e,t-this.context.start,r);return n<0?null:new I(this.context,this,n)}get firstChild(){return this.child(1,0,4)}get lastChild(){return this.child(-1,0,4)}childAfter(e){return this.child(1,e,2)}childBefore(e){return this.child(-1,e,-2)}enter(e,t,r,i=!0){if(!i)return null;let{buffer:n}=this.context,s=n.findChild(this.index+4,n.buffer[this.index+3],t>0?1:-1,e-this.context.start,t);return s<0?null:new I(this.context,this,s)}get parent(){return this._parent||this.context.parent.nextSignificantParent()}externalSibling(e){return this._parent?null:this.context.parent.nextChild(this.context.index+e,e,0,4)}get nextSibling(){let{buffer:e}=this.context,t=e.buffer[this.index+3];return t<(this._parent?e.buffer[this._parent.index+3]:e.buffer.length)?new I(this.context,this._parent,t):this.externalSibling(1)}get prevSibling(){let{buffer:e}=this.context,t=this._parent?this._parent.index+4:0;return this.index==t?this.externalSibling(-1):new I(this.context,this._parent,e.findChild(t,this.index,-1,0,4))}get cursor(){return new V(this)}get tree(){return null}toTree(){let e=[],t=[],{buffer:r}=this.context,i=this.index+4,n=r.buffer[this.index+3];if(n>i){let s=r.buffer[this.index+1],l=r.buffer[this.index+2];e.push(r.slice(i,n,s,l)),t.push(0)}return new z(this.type,e,t,this.to-this.from)}resolve(e,t=0){return this.cursor.moveTo(e,t).node}enterUnfinishedNodesBefore(e){return he(this,e)}toString(){return this.context.buffer.childString(this.index)}getChild(e,t=null,r=null){let i=K(this,e,t,r);return i.length?i[0]:null}getChildren(e,t=null,r=null){return K(this,e,t,r)}},V=class{constructor(e,t=0){if(this.mode=t,this.buffer=null,this.stack=[],this.index=0,this.bufferNode=null,e instanceof E)this.yieldNode(e);else{this._tree=e.context.parent,this.buffer=e.context;for(let r=e._parent;r;r=r._parent)this.stack.unshift(r.index);this.bufferNode=e,this.yieldBuf(e.index)}}get name(){return this.type.name}yieldNode(e){return e?(this._tree=e,this.type=e.type,this.from=e.from,this.to=e.to,!0):!1}yieldBuf(e,t){this.index=e;let{start:r,buffer:i}=this.buffer;return this.type=t||i.set.types[i.buffer[e]],this.from=r+i.buffer[e+1],this.to=r+i.buffer[e+2],!0}yield(e){return e?e instanceof E?(this.buffer=null,this.yieldNode(e)):(this.buffer=e.context,this.yieldBuf(e.index,e.type)):!1}toString(){return this.buffer?this.buffer.buffer.childString(this.index):this._tree.toString()}enterChild(e,t,r){if(!this.buffer)return this.yield(this._tree.nextChild(e<0?this._tree.node.children.length-1:0,e,t,r,this.mode));let{buffer:i}=this.buffer,n=i.findChild(this.index+4,i.buffer[this.index+3],e,t-this.buffer.start,r);return n<0?!1:(this.stack.push(this.index),this.yieldBuf(n))}firstChild(){return this.enterChild(1,0,4)}lastChild(){return this.enterChild(-1,0,4)}childAfter(e){return this.enterChild(1,e,2)}childBefore(e){return this.enterChild(-1,e,-2)}enter(e,t,r=!0,i=!0){return this.buffer?i?this.enterChild(1,e,t):!1:this.yield(this._tree.enter(e,t,r,i))}parent(){if(!this.buffer)return this.yieldNode(this.mode&1?this._tree._parent:this._tree.parent);if(this.stack.length)return this.yieldBuf(this.stack.pop());let e=this.mode&1?this.buffer.parent:this.buffer.parent.nextSignificantParent();return this.buffer=null,this.yieldNode(e)}sibling(e){if(!this.buffer)return this._tree._parent?this.yield(this._tree.index<0?null:this._tree._parent.nextChild(this._tree.index+e,e,0,4,this.mode)):!1;let{buffer:t}=this.buffer,r=this.stack.length-1;if(e<0){let i=r<0?0:this.stack[r]+4;if(this.index!=i)return this.yieldBuf(t.findChild(i,this.index,-1,0,4))}else{let i=t.buffer[this.index+3];if(i<(r<0?t.buffer.length:t.buffer[this.stack[r]+3]))return this.yieldBuf(i)}return r<0?this.yield(this.buffer.parent.nextChild(this.buffer.index+e,e,0,4,this.mode)):!1}nextSibling(){return this.sibling(1)}prevSibling(){return this.sibling(-1)}atLastNode(e){let t,r,{buffer:i}=this;if(i){if(e>0){if(this.index<i.buffer.buffer.length)return!1}else for(let n=0;n<this.index;n++)if(i.buffer.buffer[n+3]<this.index)return!1;({index:t,parent:r}=i)}else({index:t,_parent:r}=this._tree);for(;r;{index:t,_parent:r}=r)if(t>-1)for(let n=t+e,s=e<0?-1:r.node.children.length;n!=s;n+=e){let l=r.node.children[n];if(this.mode&1||l instanceof R||!l.type.isAnonymous||Y(l))return!1}return!0}move(e,t){if(t&&this.enterChild(e,0,4))return!0;for(;;){if(this.sibling(e))return!0;if(this.atLastNode(e)||!this.parent())return!1}}next(e=!0){return this.move(1,e)}prev(e=!0){return this.move(-1,e)}moveTo(e,t=0){for(;(this.from==this.to||(t<1?this.from>=e:this.from>e)||(t>-1?this.to<=e:this.to<e))&&this.parent(););for(;this.enterChild(1,e,t););return this}get node(){if(!this.buffer)return this._tree;let e=this.bufferNode,t=null,r=0;if(e&&e.context==this.buffer){e:for(let i=this.index,n=this.stack.length;n>=0;){for(let s=e;s;s=s._parent)if(s.index==i){if(i==this.index)return s;t=s,r=n+1;break e}i=this.stack[--n]}}for(let i=r;i<this.stack.length;i++)t=new I(this.buffer,t,this.stack[i]);return this.bufferNode=new I(this.buffer,t,this.index)}get tree(){return this.buffer?null:this._tree.node}};function Y(h){return h.children.some(e=>e instanceof R||!e.type.isAnonymous||Y(e))}function we(h){var e;let{buffer:t,nodeSet:r,maxBufferLength:i=be,reused:n=[],minRepeatType:s=r.types.length}=h,l=Array.isArray(t)?new q(t,t.length):t,o=r.types,u=0,f=0;function d(y,w,a,m,k){let{id:b,start:g,end:C,size:P}=l,N=f;for(;P<0;)if(l.next(),P==-1){let O=n[b];a.push(O),m.push(g-y);return}else if(P==-3){u=b;return}else if(P==-4){f=b;return}else throw new RangeError(`Unrecognized record size: ${P}`);let H=o[b],D,T,re=g-y;if(C-g<=i&&(T=S(l.pos-w,k))){let O=new Uint16Array(T.size-T.skip),B=l.pos-T.size,j=O.length;for(;l.pos>B;)j=U(T.start,O,j);D=new R(O,C-T.start,r),re=T.start-y}else{let O=l.pos-P;l.next();let B=[],j=[],L=b>=s?b:-1,J=0,$=C;for(;l.pos>O;)L>=0&&l.id==L&&l.size>=0?(l.end<=$-i&&(c(B,j,g,J,l.end,$,L,N),J=B.length,$=l.end),l.next()):d(g,O,B,j,L);if(L>=0&&J>0&&J<B.length&&c(B,j,g,J,g,$,L,N),B.reverse(),j.reverse(),L>-1&&J>0){let ie=p(H);D=Z(H,B,j,0,B.length,0,C-g,ie,ie)}else D=x(H,B,j,C-g,N-C)}a.push(D),m.push(re)}function p(y){return(w,a,m)=>{let k=0,b=w.length-1,g,C;if(b>=0&&(g=w[b])instanceof z){if(!b&&g.type==y&&g.length==m)return g;(C=g.prop(v.lookAhead))&&(k=a[b]+g.length+C)}return x(y,w,a,m,k)}}function c(y,w,a,m,k,b,g,C){let P=[],N=[];for(;y.length>m;)P.push(y.pop()),N.push(w.pop()+a-k);y.push(x(r.types[g],P,N,b-k,C-b)),w.push(k-a)}function x(y,w,a,m,k=0,b){if(u){let g=[v.contextHash,u];b=b?[g].concat(b):[g]}if(k>25){let g=[v.lookAhead,k];b=b?[g].concat(b):[g]}return new z(y,w,a,m,b)}function S(y,w){let a=l.fork(),m=0,k=0,b=0,g=a.end-i,C={size:0,start:0,skip:0};e:for(let P=a.pos-y;a.pos>P;){let N=a.size;if(a.id==w&&N>=0){C.size=m,C.start=k,C.skip=b,b+=4,m+=4,a.next();continue}let H=a.pos-N;if(N<0||H<P||a.start<g)break;let D=a.id>=s?4:0,T=a.start;for(a.next();a.pos>H;){if(a.size<0)if(a.size==-3)D+=4;else break e;else a.id>=s&&(D+=4);a.next()}k=T,m+=N,b+=D}return(w<0||m==y)&&(C.size=m,C.start=k,C.skip=b),C.size>4?C:void 0}function U(y,w,a){let{id:m,start:k,end:b,size:g}=l;if(l.next(),g>=0&&m<s){let C=a;if(g>4){let P=l.pos-(g-4);for(;l.pos>P;)a=U(y,w,a)}w[--a]=C,w[--a]=b-y,w[--a]=k-y,w[--a]=m}else g==-3?u=m:g==-4&&(f=m);return a}let M=[],W=[];for(;l.pos>0;)d(h.start||0,h.bufferStart||0,M,W,-1);let A=(e=h.length)!==null&&e!==void 0?e:M.length?W[0]+M[0].length:0;return new z(o[h.topID],M.reverse(),W.reverse(),A)}var fe=new WeakMap;function Q(h,e){if(!h.isAnonymous||e instanceof R||e.type!=h)return 1;let t=fe.get(e);return t==null&&(t=e.children.reduce((r,i)=>r+Q(h,i),1),fe.set(e,t)),t}function Z(h,e,t,r,i,n,s,l,o){let u=0;for(let x=r;x<i;x++)u+=Q(h,e[x]);let f=Math.ceil(u*1.5/8),d=[],p=[];function c(x,S,U,M,W){for(let A=U;A<M;){let y=A,w=S[A],a=Q(h,x[A]);for(A++;A<M;A++){let m=Q(h,x[A]);if(a+m>=f)break;a+=m}if(A==y+1){if(a>f){let m=x[y];c(m.children,m.positions,0,m.children.length,S[y]+W);continue}d.push(x[y])}else{let m=S[A-1]+x[A-1].length-w;d.push(Z(h,x,S,y,A,w,m,null,o))}p.push(w+W-n)}}return c(e,t,r,i,0),(l||o)(d,p,s)}var G=class{constructor(e,t,r,i,n=!1,s=!1){this.from=e,this.to=t,this.tree=r,this.offset=i,this.open=(n?1:0)|(s?2:0)}get openStart(){return(this.open&1)>0}get openEnd(){return(this.open&2)>0}static addTree(e,t=[],r=!1){let i=[new G(0,e.length,e,0,!1,r)];for(let n of t)n.to>e.length&&i.push(n);return i}static applyChanges(e,t,r=128){if(!t.length)return e;let i=[],n=1,s=e.length?e[0]:null;for(let l=0,o=0,u=0;;l++){let f=l<t.length?t[l]:null,d=f?f.fromA:1e9;if(d-o>=r)for(;s&&s.from<d;){let p=s;if(o>=p.from||d<=p.to||u){let c=Math.max(p.from,o)-u,x=Math.min(p.to,d)-u;p=c>=x?null:new G(c,x,p.tree,p.offset+u,l>0,!!f)}if(p&&i.push(p),s.to>d)break;s=n<e.length?e[n++]:null}if(!f)break;o=f.toA,u=f.toA-f.toB}return i}},ve=class{startParse(e,t,r){return typeof e=="string"&&(e=new ue(e)),r=r?r.length?r.map(i=>new _(i.from,i.to)):[new _(0,0)]:[new _(0,e.length)],this.createParse(e,t||[],r)}parse(e,t,r){let i=this.startParse(e,t,r);for(;;){let n=i.advance();if(n)return n}}},ue=class{constructor(e){this.string=e}get length(){return this.string.length}chunk(e){return this.string.slice(e)}get lineChunks(){return!1}read(e,t){return this.string.slice(e,t)}};function Ae(h){return(e,t,r,i)=>new pe(e,h,t,r,i)}var ee=class{constructor(e,t,r,i){this.parser=e,this.parse=t,this.overlay=r,this.target=i}},ae=class{constructor(e,t,r,i,n,s,l){this.parser=e,this.predicate=t,this.mounts=r,this.index=i,this.start=n,this.target=s,this.prev=l,this.depth=0,this.ranges=[]}},pe=class{constructor(e,t,r,i,n){this.nest=t,this.input=r,this.fragments=i,this.ranges=n,this.inner=[],this.innerDone=0,this.baseTree=null,this.stoppedAt=null,this.baseParse=e}advance(){if(this.baseParse){let r=this.baseParse.advance();if(!r)return null;this.baseParse=null,this.baseTree=r,this.startInner()}if(this.innerDone==this.inner.length)return this.baseTree;let e=this.inner[this.innerDone],t=e.parse.advance();if(t){this.innerDone++;let r=Object.assign(Object.create(null),e.target.props);r[v.mounted.id]=new ne(t,e.overlay,e.parser),e.target.props=r}return null}get parsedPos(){if(this.baseParse)return 0;let e=this.inner[this.innerDone];return e?e.parse.parsedPos:this.input.length}stopAt(e){if(this.stoppedAt=e,this.baseParse)this.baseParse.stopAt(e);else for(let t=this.innerDone;t<this.inner.length;t++)this.inner[t].parse.stopAt(e)}startInner(){let e=new ce(this.fragments),t=null,r=null,i=new V(new E(this.baseTree,this.ranges[0].from,0,null),1);e:for(let n,s;;){let l=!0,o;if(e.hasNode(i)){if(t){let u=t.mounts.find(f=>f.frag.from<=i.from&&f.frag.to>=i.to&&f.mount.overlay);if(u)for(let f of u.mount.overlay){let d=f.from+u.pos,p=f.to+u.pos;d>=i.from&&p<=i.to&&t.ranges.push({from:d,to:p})}}l=!1}else if(r&&(s=Ce(r.ranges,i.from,i.to)))l=s!=2;else if(!i.type.isAnonymous&&i.from<i.to&&(n=this.nest(i,this.input))){i.tree||ke(i);let u=e.findMounts(i.from,n.parser);if(typeof n.overlay=="function")t=new ae(n.parser,n.overlay,u,this.inner.length,i.from,i.tree,t);else{let f=ge(this.ranges,n.overlay||[new _(i.from,i.to)]);f.length&&this.inner.push(new ee(n.parser,n.parser.startParse(this.input,me(u,f),f),n.overlay?n.overlay.map(d=>new _(d.from-i.from,d.to-i.from)):null,i.tree)),n.overlay?f.length&&(r={ranges:f,depth:0,prev:r}):l=!1}}else t&&(o=t.predicate(i))&&(o===!0&&(o=new _(i.from,i.to)),o.from<o.to&&t.ranges.push(o));if(l&&i.firstChild())t&&t.depth++,r&&r.depth++;else for(;!i.nextSibling();){if(!i.parent())break e;if(t&&!--t.depth){let u=ge(this.ranges,t.ranges);u.length&&this.inner.splice(t.index,0,new ee(t.parser,t.parser.startParse(this.input,me(t.mounts,u),u),t.ranges.map(f=>new _(f.from-t.start,f.to-t.start)),t.target)),t=t.prev}r&&!--r.depth&&(r=r.prev)}}}};function Ce(h,e,t){for(let r of h){if(r.from>=t)break;if(r.to>e)return r.from<=e&&r.to>=t?2:1}return 0}function de(h,e,t,r,i,n){if(e<t){let s=h.buffer[e+1],l=h.buffer[t-2];r.push(h.slice(e,t,s,l)),i.push(s-n)}}function ke(h){let{node:e}=h,t=0;do h.parent(),t++;while(!h.tree);let r=0,i=h.tree,n=0;for(;n=i.positions[r]+h.from,!(n<=e.from&&n+i.children[r].length>=e.to);r++);let s=i.children[r],l=s.buffer;function o(u,f,d,p){let c=u;for(;l[c+2]+n<=e.from;)c=l[c+3];let x=[],S=[];de(s,u,c,x,S,p);let U=l[c+1]+n==e.from&&l[c+2]+n==e.to&&l[c]==e.type.id;x.push(U?e.toTree():o(c+4,l[c+3],s.set.types[l[c]],l[c+1])),S.push(l[c+1]-p),de(s,l[c+3],f,x,S,p);let M=x.length-1;return new z(d,x,S,S[M]+x[M].length)}i.children[r]=o(0,l.length,F.none,0);for(let u=0;u<=t;u++)h.childAfter(e.from)}var te=class{constructor(e,t){this.offset=t,this.done=!1,this.cursor=e.fullCursor()}moveTo(e){let{cursor:t}=this,r=e-this.offset;for(;!this.done&&t.from<r;)t.to>=e&&t.enter(r,1,!1,!1)||t.next(!1)||(this.done=!0)}hasNode(e){if(this.moveTo(e.from),!this.done&&this.cursor.from+this.offset==e.from&&this.cursor.tree)for(let t=this.cursor.tree;;){if(t==e.tree)return!0;if(t.children.length&&t.positions[0]==0&&t.children[0]instanceof z)t=t.children[0];else break}return!1}},ce=class{constructor(e){if(this.fragments=e,this.fragI=0,e.length){let t=this.curFrag=e[0];this.inner=new te(t.tree,-t.offset)}else this.curFrag=this.inner=null}hasNode(e){for(;this.curFrag&&e.from>=this.curFrag.to;)this.nextFrag();return this.curFrag&&this.curFrag.from<=e.from&&this.curFrag.to>=e.to&&this.inner.hasNode(e)}nextFrag(){if(this.fragI++,this.fragI==this.fragments.length)this.curFrag=this.inner=null;else{let e=this.curFrag=this.fragments[this.fragI];this.inner=new te(e.tree,-e.offset)}}findMounts(e,t){var r;let i=[];if(this.inner){this.inner.cursor.moveTo(e,1);for(let n=this.inner.cursor.node;n;n=n.parent){let s=(r=n.tree)===null||r===void 0?void 0:r.prop(v.mounted);if(s&&s.parser==t)for(let l=this.fragI;l<this.fragments.length;l++){let o=this.fragments[l];if(o.from>=n.to)break;o.tree==this.curFrag.tree&&i.push({frag:o,pos:n.from-o.offset,mount:s})}}}return i}};function ge(h,e){let t=null,r=e;for(let i=1,n=0;i<h.length;i++){let s=h[i-1].to,l=h[i].from;for(;n<r.length;n++){let o=r[n];if(o.from>=l)break;o.to<=s||(t||(r=t=e.slice()),o.from<s?(t[n]=new _(o.from,s),o.to>l&&t.splice(n+1,0,new _(l,o.to))):o.to>l?t[n--]=new _(l,o.to):t.splice(n--,1))}}return r}function Se(h,e,t,r){let i=0,n=0,s=!1,l=!1,o=-1e9,u=[];for(;;){let f=i==h.length?1e9:s?h[i].to:h[i].from,d=n==e.length?1e9:l?e[n].to:e[n].from;if(s!=l){let p=Math.max(o,t),c=Math.min(f,d,r);p<c&&u.push(new _(p,c))}if(o=Math.min(f,d),o==1e9)break;f==o&&(s?(s=!1,i++):s=!0),d==o&&(l?(l=!1,n++):l=!0)}return u}function me(h,e){let t=[];for(let{pos:r,mount:i,frag:n}of h){let s=r+(i.overlay?i.overlay[0].from:0),l=s+i.tree.length,o=Math.max(n.from,s),u=Math.min(n.to,l);if(i.overlay){let f=i.overlay.map(p=>new _(p.from+r,p.to+r)),d=Se(e,f,o,u);for(let p=0,c=o;;p++){let x=p==d.length,S=x?u:d[p].from;if(S>c&&t.push(new G(c,S,i.tree,-s,n.from>=c,n.to<=S)),x)break;c=d[p].to}}else t.push(new G(o,u,i.tree,-s,n.from>=s,n.to<=l))}return t}export{be as DefaultBufferLength,ne as MountedTree,v as NodeProp,X as NodeSet,F as NodeType,ve as Parser,z as Tree,R as TreeBuffer,V as TreeCursor,G as TreeFragment,Ae as parseMixed};
